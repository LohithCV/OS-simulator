<!DOCTYPE html>
<html>
<head>
  <title>CPU Scheduling</title>
  <link rel="stylesheet" type="text/css" href="scheduling.css">
</head>
<body>
  <h1>CPU Scheduling</h1>

  <h2>FCFS (First-Come, First-Serve)</h2>
  <p>FCFS (First-Come, First-Serve) CPU scheduling is one of the simplest and most straightforward scheduling algorithms in operating systems. In this approach, processes are scheduled for execution in the order they arrive in the ready queue. The process that arrives first is the first to be executed by the CPU. One advantage of FCFS scheduling is its simplicity and low overhead. The algorithm does not require complex calculations or extensive bookkeeping. Additionally, since processes are scheduled strictly based on their arrival time, there is no need to consider factors such as priority or execution time.One significant drawback is that it does not consider the duration or intensity of CPU bursts. If a long-running process arrives first, it can monopolize the CPU, leading to increased waiting times for other processes in the queue. This phenomenon, known as the "convoy effect," can result in poor overall system performance and longer average waiting times.</p>
  <button onclick="location.href='FCFS/fcfs.html'">Simulate</button>

  <h2>SJF (Shortest Job First)</h2>
  <p>SJF (Shortest Job First) CPU scheduling is a non-preemptive scheduling algorithm that aims to minimize the average waiting time and improve overall system performance. In this approach, the process with the shortest burst time is selected for execution next. The idea behind SJF scheduling is to prioritize processes that require less CPU time, assuming that shorter jobs will complete faster and reduce waiting times for other processes. SJF scheduling can be implemented in both preemptive and non-preemptive variants. In the non-preemptive version, once a process starts executing, it continues until completion, even if a shorter job arrives later. In contrast, the preemptive version allows a shorter job to preempt the currently executing process if it becomes available. Preemptive SJF scheduling requires additional bookkeeping and context switching, but it provides more flexibility in adapting to changing priorities and new arrivals. One challenge of SJF scheduling is the difficulty of accurately predicting the burst time of each process. Since the burst time is typically not known in advance, it can be estimated using historical data or statistical techniques. In practice, the accuracy of burst time estimation plays a crucial role in the effectiveness of SJF scheduling. If the estimated burst times are significantly different from the actual burst times, the scheduling decisions may not yield the expected benefits.</p>
  <button onclick="location.href='SJF/sjf.html'">Simulate</button>

  <h2>Priority Scheduling</h2>
  <p>Priority scheduling is a CPU scheduling algorithm that assigns priorities to processes based on certain criteria and schedules them accordingly. Each process is assigned a priority value, which can be determined by factors such as the importance of the process, the nature of the task, or any other relevant metrics. The process with the highest priority is given the highest preference for execution. One advantage of priority scheduling is its flexibility in addressing specific requirements and priorities within a system. It allows for the allocation of CPU time based on the significance and urgency of tasks, ensuring that important processes receive prompt attention. For instance, in a real-time system, time-critical processes can be assigned higher priorities to meet strict deadlines. However, priority scheduling can potentially lead to situations where lower-priority processes suffer from starvation, as they may be continuously preempted by higher-priority processes. To mitigate this issue, priority aging or dynamic priority adjustments can be employed, where the priorities of processes gradually increase over time to prevent starvation.</p>
  <button onclick="location.href='PRIORITY/priority.html'">Simulate</button>

  <h2>Round Robin</h2>
  <p>Round Robin (RR) CPU scheduling is a widely used preemptive scheduling algorithm in operating systems. It aims to provide fair and balanced execution among processes by allocating CPU time in a cyclic manner. Each process is given a fixed time slice called a time quantum or time slice, and the CPU switches between processes after each time quantum expires. In Round Robin scheduling, processes are arranged in a ready queue, and the CPU executes each process for a predefined time quantum. If a process does not complete within its time quantum, it is temporarily suspended, and the CPU moves on to the next process in the queue. The suspended process is placed back in the queue, ready to be executed again once its turn comes up. This approach allows all processes to get a fair share of CPU time, regardless of their burst time or priority. However, Round Robin scheduling can introduce some overhead due to frequent context switching between processes after each time quantum. This overhead can impact overall system performance, particularly in scenarios with a large number of processes or very short time quanta. Fine-tuning the time quantum is important to strike a balance between fairness and minimizing context switching overhead.</p>
  <button onclick="location.href='RR/round-robin.html'">Simulate</button>
</body>
</html>
